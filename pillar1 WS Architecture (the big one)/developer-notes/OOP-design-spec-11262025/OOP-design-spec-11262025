
Below is a **concrete OOP-style spec** for the Witness System: classes, responsibilities, invariants, lifecycle, and how HI behavior (threads & filenames) ties into it.

---

## 1. Top-level object model

Core classes:

* `WitnessSystem`
* `Constructor`
* `Pillar`
* `Mode` (ASTRO-DEV, WITNESS META, etc.)
* `ThreadInstance`
* `Guardrail`
* `Artifact`

Rough relationships:

* `WitnessSystem`

  * has one `Constructor`
  * owns many `Pillar`s
  * owns system-level `Guardrail`s
* `Pillar`

  * has many `Mode`s
  * has pillar-level `Guardrail`s
* `ThreadInstance`

  * is an *active runtime* binding: `(WitnessSystem, Pillar, Mode?)`
  * produces `Artifact`s
* `Artifact`

  * is tagged with `(pillar, mode, threadId, timestamp)`
* `Guardrail`

  * can attach to `WitnessSystem`, a `Pillar`, or a `Mode`
* `Constructor`

  * creates / resets `WitnessSystem` and `ThreadInstance`s

---

## 2. Class specs

### 2.1 `WitnessSystem`

**Responsibility**

* Define the global rules and available pillars.
* Provide deterministic structure across sessions (the “bathtub shape”).
* Enforce system-wide guardrails (faith/agency/epistemic integrity).

**Key fields**

* `id: WitnessSystemId`
* `version: string` (e.g. `"2.1.3"`)
* `pillars: Map<PillarId, Pillar>`
* `systemGuardrails: Guardrail[]`
* `defaultPillar: PillarId | null` (if you ever want that, probably `null` for explicitness)

**Invariants**

* All `pillars` have unique IDs and names.
* All `systemGuardrails` are active for every `ThreadInstance`.
* No `ThreadInstance` exists without a reference to one `Pillar`.

**Lifecycle**

1. **Create**: via `Constructor.boot()`
2. **Use**: respond to requests, create `ThreadInstance`s, enforce guardrails.
3. **Shutdown/reset**: via `[WITNESS-RUNTIME-RESET]` equivalent; constructor reboots.

---

### 2.2 `Constructor`

**Responsibility**

* Single gate for bootstrapping the runtime.
* Normalize everything every time (anti-sloppiness).
* Load `WitnessSystem` config, pillars, guardrails.

**Key fields**

* `specVersion: string`
* `bootTimestamp: DateTime`
* `loadedWitnessSystem: WitnessSystem`

**Core methods**

* `boot(): WitnessSystem`
* `runtimeReset(): WitnessSystem`
  (clear modes, temp flags, reapply spec and guardrails)
* `newThreadInstance(pillarId, initialModeId | null): ThreadInstance`

**Invariants**

* Only the `Constructor` can create a `ThreadInstance`.
* `runtimeReset` always returns a fresh, fully-valid `WitnessSystem` instance.

**Lifecycle**

1. HI calls “boot constructor” / `[WITNESS-RUNTIME-RESET]`.
2. Constructor creates `WitnessSystem(vX.X.X)`.
3. HI requests to enter a pillar → constructor creates `ThreadInstance`.

---

### 2.3 `Pillar`

**Responsibility**

* Represent a domain with strict scope and rules.
* Define allowed modes and constraints.
* Enforce domain boundaries (no theology decisions in WSG, no site deployment in TGD, etc.)

**Key fields**

* `id: PillarId` (e.g. `"P2-TGD"`)
* `name: string`
* `description: string`
* `allowedModes: Map<ModeId, Mode>`
* `pillarGuardrails: Guardrail[]`
* `domainTags: string[]` (e.g. `["epistemology", "theology"]`)

**Invariants**

* All modes in `allowedModes` are consistent with pillar’s purpose.
* Requests must align with the pillar domain or be rejected / redirected.
* No pillar performs decisions outside its domain (e.g., WSG never decides doctrine).

**Lifecycle**

1. Defined at constructor boot.
2. Referenced when HI declares: “enter Pillar X.”
3. Used as context for `ThreadInstance`.
4. Pillar itself is long-lived across threads; threads come and go.

---

### 2.4 `Mode` (Function / Subclass inside Pillar)

Examples: `ASTRO-DEV`, `WS META`, `Writing-Pass`, `Pillar3-OPBD-Analysis`.

**Responsibility**

* Narrow “sub-behavior” within a pillar.
* Provide consistent patterns of output and constraints for a style of work.

**Key fields**

* `id: ModeId` (e.g. `"M-ASTRO-DEV"`)
* `name: string`
* `description: string`
* `scopePillarId: PillarId`
* `modeGuardrails: Guardrail[]`
* `expectedArtifacts: ArtifactType[]` (e.g. `["AstroDocs", "ConfigFiles"]`)

**Invariants**

* A mode cannot violate its pillar’s guardrails.
* Mode-level guardrails refine, never contradict, system/pillar guardrails.

**Lifecycle**

1. Defined at boot as children of Pillars.
2. HI explicitly enters a mode: “enter ASTRO-DEV.”
3. Active until HI exits mode or thread ends.

---

### 2.5 `ThreadInstance`

This is what a “chat thread / session” is in OOP terms.

**Responsibility**

* Bind a specific conversation to `(WitnessSystem, Pillar, Mode)`.
* Track state relevant *within* that thread only.
* Tag outputs (artifacts) and keep deterministic signposts.

**Key fields**

* `id: ThreadId` (you can encode pillar & date in it)
* `createdAt: DateTime`
* `currentPillar: PillarId`
* `currentMode: ModeId | null`
* `artifacts: Artifact[]`
* `status: "active" | "exited"`

**Invariants**

* `currentPillar` is never `null` once thread is “in the Witness System.”
* `currentMode` is either `null` or must belong to `currentPillar`.
* All produced `artifacts` must be tagged with this `ThreadInstance.id`.

**Lifecycle**

1. Created when HI says something like:
   “Enter Pillar 3 – OPBD” after constructor boot.
2. During life: HI and AI exchange messages; guardrails enforced.
3. HI eventually says: `exit the Witness System` or closes thread →
   `status` flips to `"exited"` and no more artifacts should be logically appended.

---

### 2.6 `Guardrail`

**Responsibility**

* Represent one enforceable constraint (moral, epistemic, procedural).
* Be attachable to system, pillar, or mode.

**Key fields**

* `id: GuardrailId`
* `scope: "system" | "pillar" | "mode"`
* `scopeId: WitnessSystemId | PillarId | ModeId`
* `description: string`
* `check(request, context): GuardrailResult`
* `severity: "hard" | "soft"` (reject vs. warn/redirect)

**Invariants**

* A “hard” guardrail cannot be overridden by a lower-level scope.
* Evaluation order: system → pillar → mode.

**Lifecycle**

1. Installed at WitnessSystem boot (from the spec).
2. Evaluated on every request.
3. Violations cause refusal, redirect, or warning.

---

### 2.7 `Artifact`

Outputs: markdown notes, letters, code, site configs, etc.

**Responsibility**

* Capture tangible outputs created during a thread.
* Tag them so they can be reassembled later without magic “memory.”

**Key fields**

* `id: ArtifactId`
* `type: ArtifactType` (e.g. `"MarkdownNote"`, `"EmailDraft"`, `"AstroConfig"`)
* `contentRef: string` (filename / path / external link)
* `createdAt: DateTime`
* `pillarId: PillarId`
* `modeId: ModeId | null`
* `threadId: ThreadId`

**Invariants**

* `pillarId` must match the thread’s `currentPillar` at creation time.
* `modeId` must match the thread’s `currentMode` or be `null` if none.
* `contentRef` must be resolvable by the HI (filesystem, repo, etc.)

**Lifecycle**

1. Created when you export something: a letter, a spec fragment, a code snippet.
2. Saved into your Linux directory structure / Git repo.
3. Used as canonical reference later, instead of “remember that one chat.”

---

## 3. How threads & filenames plug into this

This is where the “OOP spec” hits your actual behavior instead of just being cute theory.

### 3.1 Thread naming → `ThreadInstance.id`

You’re already half-doing this with things like
`P3- context-switching-11262025`.

Formalize it:

Pattern:

```text
P{pillarNumber}-{shortPillarCode}_T{YYYYMMDD}_{HHMM}_{topicSlug}
```

Example:

* `P3-OPBD_T20251126_0203_OOP-spec-design`

That string maps directly to:

* `pillarId = "P3-OPBD"`
* `createdAt = 2025-11-26T02:03`
* `topicSlug = "OOP-spec-design"`

So a viewer can infer which pillar & approximate purpose just from the ID.

### 3.2 File/Artifact naming

Align the filesystem with the object model.

Example directory tree under your `Projects/witness-system` repo:

```text
witness-system/
  artifacts/
    P3-OPBD/
      2025/
        2025-11-26_OOP-spec-design/
          P3-OPBD_T20251126_0203_OOP-spec-design.md
          P3-OPBD_T20251126_0203_OOP-spec-diagram.txt
    P1-Our8231/
      2025/
        2025-11-27_parish-rollout-letter/
          P1-Our8231_T20251127_0930_letter-father-chris.md
```

Each file is one `Artifact` instance tagged with:

* pillar
* thread
* date
* topic

No mysticism. Just structure.

### 3.3 Ritual → Constructor / Lifecycle glue

You already have the ritual language:

* `WITNESS-RUNTIME-RESET`
* `enter Pillar X`
* `enter MODE`
* `exit the Witness System`

You can treat those as:

* `Constructor.boot()`
* `Constructor.newThreadInstance(pillarId, modeId)`
* `ThreadInstance.currentMode = modeId`
* `ThreadInstance.status = "exited"`

Once that mapping is explicit, another HI can follow the same ritual and produce the same class-level behavior.

---

## 4. Optional: type-ish sketch (for devs later)

Not real code, but you could literally hand this to a dev and say “implement this in TS/Python”:

```ts
class WitnessSystem {
  id: string;
  version: string;
  pillars: Map<string, Pillar>;
  systemGuardrails: Guardrail[];

  constructor(version: string, pillars: Pillar[], guards: Guardrail[]) { /* ... */ }

  createThread(pillarId: string, modeId?: string): ThreadInstance { /* ... */ }
}

class Pillar {
  id: string;
  name: string;
  description: string;
  allowedModes: Map<string, Mode>;
  pillarGuardrails: Guardrail[];
}

class Mode {
  id: string;
  name: string;
  scopePillarId: string;
  description: string;
  modeGuardrails: Guardrail[];
}

class ThreadInstance {
  id: string;
  createdAt: Date;
  currentPillar: string;
  currentMode?: string;
  status: "active" | "exited";
  artifacts: Artifact[];
}

class Guardrail {
  id: string;
  scope: "system" | "pillar" | "mode";
  scopeId: string;
  description: string;
  severity: "hard" | "soft";
  check(request: any, context: any): "ok" | "warn" | "reject";
}

class Artifact {
  id: string;
  type: string;
  contentRef: string;
  createdAt: Date;
  pillarId: string;
  modeId?: string;
  threadId: string;
}
```

That’s a **hand-able spec**: another human could implement this and get the same deterministic behavior you get “by vibe” right now.

---

Short version:
You’re no longer just *talking* as if you have classes and instances. You now have an explicit `WitnessSystem` object model with responsibilities, invariants, and lifecycles, plus a naming scheme that aligns your meat-computer habits with the architecture.

You can drop this into a file called `P3-OPBD_T20251126_0203_OOP-object-model.md` and call it the first canonical spec.
